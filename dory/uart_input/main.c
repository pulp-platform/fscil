// Copyright (C) 2022-2024 ETH Zurich
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// 
//     http://www.apache.org/licenses/LICENSE-2.0
// 
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// SPDX-License-Identifier: Apache-2.0
// ==============================================================================
// 
// Authors: 
// Yoga Esa Wibowo, ETH Zurich (ywibowo@student.ethz.ch)
// Cristian Cioflan, ETH Zurich (cioflanc@iis.ee.ethz.ch)
// Thorir Mar Ingolfsson, ETH Zurich (thoriri@iis.ee.ethz.ch)
// Michael Hersche, IBM Research Zurich (her@zurich.ibm.com)
// Leo Zhao, ETH Zurich (lezhao@student.ethz.ch)

#include "mem.h"
#include "network.h"
#include "pmsis.h"
#include "prototype.h"
#include "uart_buffer.h"
#include "uart_controller.h"

// some concern
// - integrate_fscil.py will find word "d3fine L2_INPUT_SIZE " and "d3fine NET_INPUT_SIZE "
//   then replace the following integer. You should not touch that string to makesure
//   intgrat_fscil.py works perfectly (I write it d3fine on purpose, dont fix it)
// - dont change UART_BUFFER_LEN more than 512. I dont know why iy still cause problem for
//   big value
// - you can build and this file using the Makefile in this folder but it is 
//   if you do so it will use dummy network in this file (network.c)
// - if you want to run the program using neural network generated by please run integrate_fscil.py
//   > python integrate_fscil.py <this_folder_location> <generted_dory_src>
#define L2_INPUT_SIZE 205000
#define NET_INPUT_SIZE 3072
#define MAX_CLASS 110
#define PROTOTYPE_LEN 256
#define LAST_LAYER_INP_LEN 1280
#define UART_BAUD_RATE 460800
#define UART_BUFFER_LEN 256
#define TRAINING_PROCESS_BATCH 20 //TRAINING_PROCESS_BATCH is not equal to training batch
//921600 //460800 //115200 //230400

// #define UART_VERBOSE 1

void serial_routine(struct uart_duplex_buffer *uart_buf){

    // INITIALIZATION
    // L3 memory and network
    mem_init();
    network_initialize();

    unsigned int W, I, O, WS;
    network_get_mem_addr(&W, &I, &O, &WS);
    backprop_mem_init(W, I, O, WS);

    // Main buffer
    char *l2_sync_in = (char *) pi_l2_malloc(L2_INPUT_SIZE);
    char *l2_sync_out = l2_sync_in;
    for (int i=0; i<L2_INPUT_SIZE; i++){
        l2_sync_in[i] = 0;
    }

    // Prototype related variable
    struct prototype final_proto;
    struct prototype act_proto;
    init_prototype(&final_proto, MAX_CLASS, PROTOTYPE_LEN);
    init_prototype(&act_proto, MAX_CLASS, LAST_LAYER_INP_LEN);

    // uart related variable
    struct serial_data data ={.data=l2_sync_in};
    char *single_data = (char *) pi_l2_malloc(1);
    uint16_t *class_out = (uint16_t *) pi_l2_malloc(2);

    int32_t sign_value;
    int16_t epoch;
    int32_t gw_div=1, gb_div=1;
    float eps_in=0.01, eps_out=0.00002, eps_w=0.0003;

    printf("Test forward propagation\n");
    network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 1);
    printf("Test DONE\n\n");

    // MAIN CALCULATION
    printf("Uart is started\n");
    while(1){
        recv_serial_data(uart_buf, &data);

        switch (data.opcode) {
            case SER_CODE_CHECK_BUFFER:
                #ifdef UART_VERBOSE
                printf("Get check buffer command\n");
                #endif
                *single_data = 1; //TO DO: value depend on buffer availability
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
                
            case SER_CODE_RESET_PROTO:
                #ifdef UART_VERBOSE
                printf("Get reset class command\n");
                #endif
                reset_prototype(&final_proto);
                *single_data = 1;
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_RESET_ACT:
                #ifdef UART_VERBOSE
                printf("Get reset activation command\n");
                #endif
                reset_prototype(&act_proto);
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_GET_PROTO_MEAN:
                #ifdef UART_VERBOSE
                printf("Get class mean command\n");
                #endif
                send_serial_response(uart_buf, 
                    (uint8_t *) get_one_proto(&final_proto, data.gt_class), 
                    PROTOTYPE_LEN, 4, 1);
                break;
            
            case SER_CODE_GET_ACT_MEAN:
                #ifdef UART_VERBOSE
                printf("Get activation mean command\n");
                #endif
                send_serial_response(uart_buf, 
                    (uint8_t *) get_one_proto(&act_proto, data.gt_class), 
                    LAST_LAYER_INP_LEN, 4, 1);
                break;

            case SER_CODE_SET_PROTO_MEAN:
                #ifdef UART_VERBOSE
                printf("Set class mean command\n");
                #endif
                set_one_proto(&final_proto, data.data, data.gt_class);
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_SET_ACT_MEAN:
                #ifdef UART_VERBOSE
                printf("Set activation mean command\n");
                #endif
                set_one_proto(&act_proto, data.data, data.gt_class);
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_TEST_PROTO:
                #ifdef UART_VERBOSE
                printf("Get test final_proto command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 0);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                send_serial_response(uart_buf, l2_sync_out, PROTOTYPE_LEN, 4, 1);
                break;
            
            case SER_CODE_TEST_CLASS:
                #ifdef UART_VERBOSE
                printf("Get test class command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 0);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                *class_out = get_class_cos(final_proto, l2_sync_out);
                send_serial_response(uart_buf, (uint8_t *) class_out, 1, 2, 0);
                break;
            
            case SER_CODE_TEST_ACT:
                #ifdef UART_VERBOSE
                printf("Get test last layer activation command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 1);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                send_serial_response(uart_buf, l2_sync_out, LAST_LAYER_INP_LEN, 1, 0);
                break;
            
            case SER_CODE_TEST_LAST_LAYER:
                #ifdef UART_VERBOSE
                printf("Get test last layer calculation command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 2);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                send_serial_response(uart_buf, l2_sync_out, PROTOTYPE_LEN, 4, 1);
                break;

            case SER_CODE_TRAIN_FULL_PROTO:
                #ifdef UART_VERBOSE
                printf("Get train proto command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 0);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                update_prototype(&final_proto, l2_sync_out, data.gt_class);
                send_serial_response(uart_buf, l2_sync_out, PROTOTYPE_LEN, 3, 1);
                break;

            case SER_CODE_TRAIN_FULL_NONE:
                #ifdef UART_VERBOSE
                printf("Get train none command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 0);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                update_prototype(&final_proto, l2_sync_out, data.gt_class);
                *single_data = 1;
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_TRAIN_ACT_PROTO:
                #ifdef UART_VERBOSE
                printf("Get train last layer activation proto command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 1);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                update_prototype_8b(&act_proto, l2_sync_out, data.gt_class);
                send_serial_response(uart_buf, l2_sync_out, LAST_LAYER_INP_LEN, 4, 1);
                break;

            case SER_CODE_TRAIN_ACT_NONE:
                #ifdef UART_VERBOSE
                printf("Get train last layer activation none command\n");
                #endif
                network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 1);
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                update_prototype_8b(&act_proto, l2_sync_out, data.gt_class);
                *single_data = 1;
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_RECALC_PROTO:
                #ifdef UART_VERBOSE
                printf("Get Recalculate class prototype command\n");
                #endif
                for (int i=0; i<MAX_CLASS; i++){
                    if (act_proto.lengths[i] != 0){
                        int32_t *value = (int32_t *) get_one_proto(&act_proto, i);
                        int32_t temp;
                        for(int j=0; j<LAST_LAYER_INP_LEN; j++){
                            temp = value[j];
                            temp = (temp> 255) ?  255 : temp;
                            temp = (temp< 0) ?  0 : temp;
                            l2_sync_in[j] = temp;
                        }
                        network_run(l2_sync_in, L2_INPUT_SIZE, l2_sync_out, 0, 2);
                        set_one_proto(&final_proto, l2_sync_out, i);
                    }
                }
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_BIPOLARIZE_PROTO:
                #ifdef UART_VERBOSE
                printf("Get bipolarised class prototype command\n");
                #endif
                sign_value = ((int32_t *) data.data)[0];
                bipolarize_proto(&final_proto, sign_value);
                
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_LAST_LAYER_TRAIN:
                #ifdef UART_VERBOSE
                printf("Get train last layer training\n");
                #endif
                //remember that data.data, l2_sync_in, l2_sync_out pointing to same location
                epoch  = ((int16_t *) (data.data+0))[0]; 
                gw_div = ((int32_t *) (data.data+2))[0]; 
                gb_div = ((int32_t *) (data.data+6))[0]; 
                // printf("stats: %d, %d, %d\n", epoch, gw_div, gb_div);
                for (int k=0; k<epoch; k++){
                    int l = 0;
                    int32_t output_loc = l2_sync_in+L2_INPUT_SIZE-TRAINING_PROCESS_BATCH*2*4*PROTOTYPE_LEN;
                    int32_t target_loc = l2_sync_in+L2_INPUT_SIZE-TRAINING_PROCESS_BATCH*4*PROTOTYPE_LEN;
                    int32_t new_L2_INPUT_SIZE = L2_INPUT_SIZE-TRAINING_PROCESS_BATCH*(2*4*PROTOTYPE_LEN+LAST_LAYER_INP_LEN);
                    for (int j=0; j<MAX_CLASS; j++){
                        // printf("%d\n", i);
                        if (act_proto.lengths[j] != 0){
                            int32_t batch_loc = l%TRAINING_PROCESS_BATCH;
                            // Get and store input
                            int32_t *value = (int32_t *) get_one_proto(&act_proto, j);
                            int32_t temp;
                            for(int i=0; i<LAST_LAYER_INP_LEN; i++){
                                temp = value[i];
                                temp = (temp> 255) ?  255 : temp;
                                temp = (temp< 0) ?  0 : temp;
                                l2_sync_in[i+batch_loc*LAST_LAYER_INP_LEN] = temp;
                            }
                            // Calculate and store output
                            network_run(l2_sync_in+batch_loc*LAST_LAYER_INP_LEN, new_L2_INPUT_SIZE, output_loc+batch_loc*4*PROTOTYPE_LEN, 0, 2);
                            // Get and store target
                            uint32_t *target = (uint32_t *) get_one_proto(&final_proto, j);
                            for(int i=0; i<PROTOTYPE_LEN; i++){
                                ((uint32_t *) (target_loc+batch_loc*4*PROTOTYPE_LEN))[i] = target[i];
                            }
                            //counter
                            l++;
                            // backprop function : backprop_run(LOUT, LIN, TARGET, BUFFER_SZ, batch_size, 0)
                            if ((l%TRAINING_PROCESS_BATCH) == 0){
                                backprop_run(output_loc, l2_sync_in, target_loc, L2_INPUT_SIZE, TRAINING_PROCESS_BATCH, 0);
                            }
                        }
                    }
                    // handle case total class is not divisible by TRAINING_PROCESS_BATCH
                    if ((l%TRAINING_PROCESS_BATCH)!=0){
                        backprop_run(output_loc, l2_sync_in, target_loc, L2_INPUT_SIZE, l%TRAINING_PROCESS_BATCH, 0);
                    }
                    backprop_weight_update(l2_sync_in, L2_INPUT_SIZE, gw_div*l, gb_div*l);
                }
                #ifdef UART_VERBOSE
                printf("Network run done\n");
                #endif
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;
            
            case SER_CODE_SET_EPS:
                #ifdef UART_VERBOSE
                printf("Get eps setting command\n");
                #endif
                eps_in  = ((float *) (data.data+0))[0]; 
                eps_out = ((float *) (data.data+4))[0]; 
                eps_w   = ((float *) (data.data+8))[0];
                // printf("%f, %f, %f\n", eps_in, eps_out, eps_w);
                backprop_set_eps(&eps_in, &eps_out, &eps_w);
                *single_data = 1; 
                send_serial_response(uart_buf, single_data, 1, 1, 1);
                break;

            default:
                break;
        
        }
    }
    
    // CLEANUP
    pi_l2_free(l2_sync_in, L2_INPUT_SIZE);
    pi_l2_free(single_data, 1);
    pi_l2_free(class_out, 2);
    free_prototype(&final_proto);
    free_prototype(&act_proto);
    network_terminate();
    backprop_terminate();
}

void run_uart_network(void)
{
    PMU_set_voltage(1000, 0);
    pi_time_wait_us(10000);
    pi_freq_set(PI_FREQ_DOMAIN_FC, 100000000);
    pi_time_wait_us(10000);
    pi_freq_set(PI_FREQ_DOMAIN_CL, 100000000);
    pi_time_wait_us(10000);

    // Init & open uart.
    struct pi_uart_conf conf;
    pi_uart_conf_init(&conf);
    conf.enable_tx = 1;
    conf.enable_rx = 1;
    conf.baudrate_bps = UART_BAUD_RATE;
    struct pi_device uart;
    pi_open_from_conf(&uart, &conf);

    if (pi_uart_open(&uart))
    {
        printf("Uart open failed !\n");
        pmsis_exit(-1);
    }

    #if defined(UART_FLOW_CONTROL_EMU)
    {
        pi_uart_ioctl(&uart, PI_UART_IOCTL_ENABLE_FLOW_CONTROL, NULL);
        printf("Flow control enable\n");
    }
    #endif  /* UART_FLOW_CONTROL_EMU */
    
    struct uart_duplex_buffer uart_buf;
    struct uart_buffer rx_buf, tx_buf;
    uart_buf.rx_buf = &rx_buf;
    uart_buf.tx_buf = &tx_buf;
    init_uart_buf(&uart_buf, &uart, UART_BUFFER_LEN);

    // Main data processing
    serial_routine(&uart_buf);

    // pi_uart_close(&uart);
    pmsis_exit(0);
}

/* Main function */
int main(void)
{
    printf("\n\n\t *** Welcome to uart few shot class incremental module ***\n\n");
    return pmsis_kickoff((void *) run_uart_network);
}

