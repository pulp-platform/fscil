
# Copyright (C) 2022-2024 ETH Zurich
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0

#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# SPDX-License-Identifier: Apache-2.0
# ==============================================================================
#
# Authors: 
# Yoga Esa Wibowo, ETH Zurich (ywibowo@student.ethz.ch)
# Cristian Cioflan, ETH Zurich (cioflanc@iis.ee.ethz.ch)
# Thorir Mar Ingolfsson, ETH Zurich (thoriri@iis.ee.ethz.ch)
# Michael Hersche, IBM Research Zurich (her@zurich.ibm.com)
# Leo Zhao, ETH Zurich (lezhao@student.ethz.ch)


import os
import re
import sys
import shutil
from copy import deepcopy

def is_empty_line(inp):
    temp = inp.replace(" ", "")
    temp = temp.replace("\t", "")
    temp = temp.replace("\r", "")
    temp = temp.replace("\n", "")
    if len(temp) == 0:
        return True
    elif len(temp) >= 2:
        return (temp[0:2] == "//")
    else:
        return False

def parse_int_with_cue(filename, cue):
    with open(filename, "r") as f:
        text = f.read()
        start = text.find(cue)+len(cue)
        end = start
        while (text[end].isdigit()):
            end += 1
    ret = 0
    if text[start:end].isdigit():
        ret = int(text[start:end])
    return ret

def get_files(path):
    for file in os.listdir(path):
        abs_path = os.path.join(path, file)
        if os.path.isfile(abs_path):
            yield abs_path

def remove_duplicate(filename, pattern):
    with open(filename, "r+") as fp:
        lines = fp.readlines() 
        len_lines = len(lines)

        if (pattern[-1]=="\n"):
            p = pattern
        else:
            p = pattern + "\n"
        prev_line_found = False

        for i in range(len_lines-1, -1, -1):
            if is_empty_line(lines[i]):
                continue
            elif p in lines[i]:
                if (prev_line_found):
                    lines.pop(i)
                prev_line_found = True
            else:
                prev_line_found = False

        fp.seek(0)
        fp.truncate()
        fp.writelines(lines)

def remove_lines(filename, string_patterns, save_file=True):
    with open(filename, "r+") as fp:
        lines = fp.readlines() 
        len_lines = len(lines)

        for i in range(len_lines-1, -1, -1):
            for s in string_patterns:
                if s in lines[i]:
                    lines.pop(i)
                    break
        
        if save_file:
            fp.seek(0)
            fp.truncate()
            fp.writelines(lines)
    
    return ''.join(lines)

def replace_strings(filename, string_tuples, save_file=True):
    with open(filename, "r+") as fp:
        text = fp.read() 

        for s1,s2 in string_tuples:
            text = re.sub(s1, s2, text)
        
        if save_file:
            fp.seek(0)
            fp.truncate()
            fp.write(text)
    
    return text

if __name__=="__main__":
    template_dir     = sys.argv[1] # should pointed to fscil/dory/uart input folder
    dory_network_dir = sys.argv[2] # application folder generated by dory
    
    # Edit inc/network.h
    filename = os.path.join(dory_network_dir,"inc/network.h")
    slave_stack = parse_int_with_cue(filename, "cluster_task.slave_stack_size = ")
    stack = parse_int_with_cue(filename, "cluster_task.stack_size = ")
    l1_size = parse_int_with_cue(filename, "pmsis_l1_malloc(")
    if (l1_size==0):
        l1_size = parse_int_with_cue(filename, "0, L1_buffer, ")
    string_to_replace = [
        ("void network_initialize\(\);\n" , 
            "void network_initialize(); \n"+
            "void backprop_mem_init(unsigned int W, unsigned int I, unsigned int O, unsigned int WS);\n" +
            "void backprop_set_eps(float *e_in, float *e_out, float *e_w);\n"+
            "void network_get_mem_addr(unsigned int *W, unsigned int *I, unsigned int *O, unsigned int *WS);\n"
        ),
        ("void network_run_cluster\(void \* args\);\n" ,
            "void network_run_cluster(void * args); \n" +
            "void network_run_cluster_conv(void * args);\n" +
            "void network_run_cluster_last(void * args);\n" +
            "void backprop_run_cluster_last(void * args);\n"
        ),
        ("void network_run\(void \*l2_buffer, size_t l2_buffer_size, void \*l2_final_output, int exec\);" ,
            "void network_run(void *l2_buffer, size_t l2_buffer_size, void *l2_final_output, int exec, int type_run);\n" +
            "void backprop_run(void *l2_buffer, void *last_layer_in, void *target_label, size_t l2_buffer_size, int batch_size, int exec);"
        ),
        ("void execute_layer_fork\(void \*arg\);\n" ,
            "void execute_layer_fork(void *arg); \n" +
            "void backprop_weight_update(void *l2_buffer, int l2_buffer_sz, int divider_w, int divider_b);\n"
        ),
    ]
    print(filename)
    replace_strings(filename, string_to_replace)

    # Edit src/network.c
    # edit file
    filename = os.path.join(dory_network_dir,"src/network.c")
    num_layers = parse_int_with_cue(filename, "i + 1 < ")
    string_to_replace = [
        ("#define VERBOSE 1\n",
           "// #define VERBOSE 1 \n"),
        ("  print_perf\(", 
           "  // print_perf()"),
        ("\nint cycle_network_execution;" , 
            "\nstatic int cycle_network_execution;\n\n"+
            "void network_get_mem_addr(unsigned int *W, unsigned int *I, unsigned int *O, unsigned int *WS){\n" +
            "  *W = L3_weights;\n" +
            "  *I = L3_input;\n" +
            "  *O = L3_output;\n" +
            "  *WS = L3_weights_size;\n" +
            "}"
        ),
        ("void network_run\(void \*l2_buffer, size_t l2_buffer_size, void \*l2_final_output, int exec\)",
            "void network_run(void *l2_buffer, size_t l2_buffer_size, void *l2_final_output, int exec, int type_run)" 
        ),
        ("  pi_cluster_task\(&cluster_task, network_run_cluster, args\);",
            "  if(type_run==0){ pi_cluster_task(&cluster_task, network_run_cluster, args);}\n" +
            "  else if (type_run==1) {pi_cluster_task(&cluster_task, network_run_cluster_conv, args);}\n" +
            "  else if (type_run==2) {pi_cluster_task(&cluster_task, network_run_cluster_last, args);}"
        ),
    ]
    text1 = replace_strings(filename, string_to_replace, save_file=False)

    # get template
    filename = os.path.join(template_dir,"network_template.c")
    string_to_replace = [
        ("XX_NUM_LAYERS-2" , str(num_layers-2)),
        ("XX_NUM_LAYERS-1" , str(num_layers-1)),
        ("XX_NUM_LAYERS" , str(num_layers)),
    ]
    text2 = replace_strings(filename, string_to_replace, save_file=False)

    # save to file
    if "\n\nvoid network_run_cluster_conv(void *args)" in text1:
        idx = text1.find("\n\nvoid network_run_cluster_conv(void *args)")
        text1 = text1[:idx]
    filename = os.path.join(dory_network_dir,"src/network.c")
    text_file = open(filename, "w")
    text_file.write(text1+text2)
    text_file.close()
    print(filename)

    #TODO: these copied file is still not adaptive
    shutil.copy(
        os.path.join(template_dir,"main_template.c"), 
        os.path.join(dory_network_dir,"src/main.c")
    )
    print(os.path.join(dory_network_dir,"src/main.c"))
    shutil.copy(
        os.path.join(template_dir,"backprop_template.c"), 
        os.path.join(dory_network_dir,"src/backprop.c")
    )
    print(os.path.join(dory_network_dir,"src/backprop.c"))
    shutil.copy(
        os.path.join(template_dir,"BackpropFullyConnected63_template.c"), 
        os.path.join(dory_network_dir,"src/BackpropFullyConnected63.c")
    )
    print(os.path.join(dory_network_dir,"src/BackpropFullyConnected63.c"))
    shutil.copy(
        os.path.join(template_dir,"BackpropFullyConnected63_L2_template.c"), 
        os.path.join(dory_network_dir,"src/BackpropFullyConnected63_L2.c")
    )
    print(os.path.join(dory_network_dir,"src/BackpropFullyConnected63_L2.c"))
    shutil.copy(
        os.path.join(template_dir,"BackpropLoss_template.c"), 
        os.path.join(dory_network_dir,"src/BackpropLoss.c")
    )
    print(os.path.join(dory_network_dir,"src/BackpropLoss.c"))
    shutil.copy(
        os.path.join(template_dir,"BackpropFullyConnected63_template.h"), 
        os.path.join(dory_network_dir,"inc/BackpropFullyConnected63.h")
    )
    print(os.path.join(dory_network_dir,"inc/BackpropFullyConnected63.h"))
    shutil.copy(
        os.path.join(template_dir,"BackpropFullyConnected63_L2_template.h"), 
        os.path.join(dory_network_dir,"inc/BackpropFullyConnected63_L2.h")
    )
    print(os.path.join(dory_network_dir,"inc/BackpropFullyConnected63_L2.h"))
    shutil.copy(
        os.path.join(template_dir,"BackpropLoss_template.h"), 
        os.path.join(dory_network_dir,"inc/BackpropLoss.h")
    )
    print(os.path.join(dory_network_dir,"inc/BackpropLoss.h"))